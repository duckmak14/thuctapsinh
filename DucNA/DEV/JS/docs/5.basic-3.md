# Tìm hiểu về JS cơ bản tiếp 
1. LET 
- Trong JS trước phiên bản ES2015 thì chỉ có hai phạm vi được sử dụng đó là `global` và `function` 
- Đến phiên bản ES2015 thì có thêm một phạm vi là `Block Scope` và được tạo bởi `let` và `const` 
* `Global scope` Các biến được khai báo Globally. Và được truy cập ở bất cứ đâu trong chương trình JS 
* Biến được khai báo bên trong hàm sẽ có phạm vi `Function scope`
* `Block scope` : sẽ có các đặc điểm sau 
    * Các biến được khai báo bằng var không thể là `block scope` 
    * Các biến khai báo bằng `let` có thể là `block scope` 
    * Các biến ở bên trong một khối không thể truy cập từ bên ngoài
* Biến có thể bị biến đổi lại giá trị khi sử dụng `var` nhưng mà sử dụng `let` thì không 
```js
var x = 10;

{
  var x = 2;

}
document.getElementById("x").innerHTML = x;
// return x  2
```


```js
var x = 10;

{
  let x = 2;

}
document.getElementById("x").innerHTML = x;
// return x  10
```
* Trong vòng lặp thì khai báo bằng `var` giá trị sẽ thay đổi khi kết thúc vòng lặp còn `let` thì không
```js
let i = 5;
for (let i = 0; i < 10; i++) {
}
document.getElementById("i").innerHTML = ; //return 5 
```
```js
var i = 5;
for (var) i = 0; i < 10; i++) {
}
document.getElementById("i").innerHTML = ; //return 10
```
* Khi khai báo biến thì không thể khai báo lại biến khi đã dùng `let` còn `var` thì có 
```js
var x=32;
var x=3 ;
```
```js
let x=32;
let x=3 ; // sẽ xảy ra lỗi 
```
* Các biến được khai báo với `let` không sử dụng được `hoisting` 

2. Const 
* Hoạt động như một biến bình thường khác ở một điểm là nó sẽ không thể được gán lại
* Khi khai báo một biến bằng `const` thì phải gán luôn giá trị cho chúng
```js
const PI = 3.141592653589793;
PI = 3.14; // sẽ xảy ra lỗi 
```
* Nếu khai báo một `object` bằng `const` thì vẫn có thể thay đổi giá trị của `object` này. Nhưng không thể gán lại nó 
* Cũng như là `let` thì `const` không được `hoisting` 

3. Arrow Function
* Là một cách viết `function` một cách ngắn gọn hơn 
```js
hello = () => {
  return "Hello World!";
}
```
* Với `this` thì khi ở trong hàm này cũng có một ý nghĩa khác. Nó không có rằng buộc nào với hàm hết 

4. Classes 
* Trong phiên bản ES6 thì đã cập nhật thêm `classes` 
* `classes` là một loại hàm. Và thay vì được khởi tạo bởi `function` thì nó sẽ được chạy với `class` và nó luôn luôn được thêm `constructor()` vì đây là bắt buộc 
```js
class Car {
  constructor(brand) {
    this.carname = brand;
  }
}

mycar = new Car("Ford");
```
* Có thể sử dụng được việc kết hợp với `method` như bình thường nhưng không thể được với `static method`
```js
class Car {
  constructor(brand) {
    this.carname = brand;
  }
  static hello() {
    return "Hello!!";
  }
}

mycar = new Car("Ford");

document.getElementById("demo").innerHTML = Car.hello();
// sẽ xảy ra lỗi 
```
* Để tạo ra được một lớp thừa kế thì ta phải sử dụng `extends` . Thì `class` được kế thừa sẽ sử dụng được các `method` của `class parents`
```js
class Car {
  constructor(brand) {
    this.carname = brand;
  }
  present() {
    return 'I have a ' + this.carname;
  }
}

class Model extends Car {
  constructor(brand, mod) {
    super(brand);
    this.model = mod;
  }
  show() {
    return this.present() + ', it is a ' + this.model;
  }
}

mycar = new Model("Ford", "Mustang");
document.getElementById("demo").innerHTML = mycar.show();// class model có thể sử dụng present() do được thừa kế class car 
```
* Trong class cũng có thể sử dụng được 2 method `get` và `set`
* Các khai báo bằng `class` không được `Hoisting`
* Khi sử dụng khai báo `class` nó mặc định được dùng trong chế độ `strick mode`

5. Debbuging 
* Trong lập trình có thể chứa lỗi. Nhiều lỗi trong số đó rất khó nhận biết
* Thông thường thì khi xảy ra lỗi sẽ không được báo lỗi và sẽ không nhận ra được rồi tìm thấy nó ở đâu 
* Tìm kiếm và sửa lỗi được gọi là `debbugging`
* Tất cả các trình duyệt hiện nay đề có tích hợp gỡ lỗi `javascript` 
* Trình gỡ lỗi có thể bật tắt nhưng bắt buộc phải báo lỗi cho người dùng 
* Thông thường trình gỡ lỗi được kích hoạt trong trình duyệt bằng phím `F12` 
* Để trình duyệt hỗ trợ gỡ lỗi thì bạn có thể sử dụng `console.log()` 
```js
<script>
a = 5;
b = 6;
c = a + b;
console.log(c);
</script>
```
* Có thể đặt các điểm dừng trong đoạn mã JS. Khi dừng đoạn mã rồi thì có thể kiểm tra được các giá trị JS. Sau khi kiểm tra xong có thể tiếp tục thực thi mã 
* Từ khóa `debbugging` sẽ dừng thực thi của JS, và gọi hàm nếu có sẵn debugging function 
* Điều này tương tự việc thiết lập điểm dừng trong việc gỡ lỗi 
```js
var x = 15 * 5;
debugger;
document.getElementById("demo").innerHTML = x;
```
Điều trên sẽ dừng thực thi trước khi thực hiện dòng thứ 3