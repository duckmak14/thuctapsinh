# Tài liệu các bước cảnh báo qua telegram 

1. Tìm ID chat

Bước 1: Tạo bot 
```
https://telegram.me/botfather
```
vào link để chat với `BotFather`

Chọn newbot 

![](../images/canh-bao-tele/screen_14.png)

Bước 2: Sau khi chọn newbot thì ta chọn tên cho con bot đó và tên người dùng cho bot. Tên phải được kết thúc bằng `bot`

![](../images/canh-bao-tele/screen_14.png)

Bước 3: Tiếp theo ta tìm kiến bot bằng `@name-bot` để có thể bắt đầu chat với bot 

![](../images/canh-bao-tele/screen_1.png)

![](../images/canh-bao-tele/screen_3.png)

Lưu ý token của bot này ta sẽ phải sử dụng để lấy ID 

Bước 4: Bắt đầu start rồi chat với bot đó 

![](../images/canh-bao-tele/screen_2.png)

Bước 5: lấy ID của telegram

![](../images/canh-bao-tele/screen_2.png)


vào HTTP API của tele để lấy ID chat 
- Cú pháp
```
https://api.telegram.org/botToken/getUpdates
```
- ví dụ 
```
https://api.telegram.org/bot908652940:AAGYGskRFhRr42cy4or1FynDMtfKKzTIs6w/getUpdates
```

2. Cấu hình check_mk 

Tạo file `telegram.py`
```
vi /omd/sites/monitoring/share/check_mk/notifications/telegram.py
```

Nội dung file `telegram.py` như sau:
```
#!/usr/bin/env python
# Telegram V2

# Copyright Mathias Kettner  2013  mk@mathias-kettner.de
#           Stefan Gehn      2016  stefan+cmk@srcxbox.net

# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

# Telegram notification based on asciimail notification from
# check_mk 1.2.6p16.

import os
import re
import sys
reload(sys)
sys.setdefaultencoding('utf8')
import urllib
import urllib2
### CHANGE THESE ###
telegram_bot_token = 'TOKEN-HERE'
####################

tmpl_host_text = """*Check_MK: $HOSTNAME$ - $EVENT_TXT$*
```
Host:     $HOSTNAME$
Alias:    $HOSTALIAS$
Address:  $HOSTADDRESS$
Event:    $EVENT_TXT$
Output:   $HOSTOUTPUT$

$LONGHOSTOUTPUT$```"""

tmpl_service_text = """*Check_MK: $HOSTNAME$/$SERVICEDESC$ $EVENT_TXT$*
```
Host:     $HOSTNAME$
Alias:    $HOSTALIAS$
Address:  $HOSTADDRESS$
Service:  $SERVICEDESC$
Event:    $EVENT_TXT$
Output:   $SERVICEOUTPUT$

$LONGSERVICEOUTPUT$```"""

def substitute_context(template, context):
    # First replace all known variables
    for varname, value in context.items():
        template = template.replace('$'+varname+'$', value)

    # Remove the rest of the variables and make them empty
    template = re.sub("\$[A-Z_][A-Z_0-9]*\$", "", template)
    return template

def construct_message_text(context):
    notification_type = context["NOTIFICATIONTYPE"]
    if notification_type in [ "PROBLEM", "RECOVERY" ]:
        txt_info = "$PREVIOUS@HARDSHORTSTATE$ -> $@SHORTSTATE$"
    elif notification_type.startswith("FLAP"):
        if "START" in notification_type:
            txt_info = "Started Flapping"
        else:
            txt_info = "Stopped Flapping ($@SHORTSTATE$)"
    elif notification_type.startswith("DOWNTIME"):
        what = notification_type[8:].title()
        txt_info = "Downtime " + what + " ($@SHORTSTATE$)"
    elif notification_type == "ACKNOWLEDGEMENT":
        txt_info = "Acknowledged ($@SHORTSTATE$)"
    elif notification_type == "CUSTOM":
        txt_info = "Custom Notification ($@SHORTSTATE$)"
    else:
        txt_info = notification_type # Should neven happen

    txt_info = substitute_context(txt_info.replace("@", context["WHAT"]), context)

    context["EVENT_TXT"] = txt_info

    if context['WHAT'] == 'HOST':
        tmpl_text = tmpl_host_text
    else:
        tmpl_text = tmpl_service_text

    return substitute_context(tmpl_text, context)

def fetch_notification_context():
    context = {}
    for (var, value) in os.environ.items():
        if var.startswith("NOTIFY_"):
            context[var[7:]] = value.decode("utf-8")
    return context

def send_telegram_message(token, chat_id, text):
    url = 'https://api.telegram.org/bot%s/sendMessage' % (token)
    data = urllib.urlencode({'chat_id':chat_id, 'text':text, 'parse_mode':'Markdown'})
    #print("sending telegram message, url '%s', chat id '%s', text '%s'" % (url, chat_id, text))
    try:
        urllib2.urlopen(url, data).read()
    except urllib2.URLError, e:
        sys.stdout.write('Cannot send Telegram message: HTTP-Error %s %s\n' % (e.code, e))

def main():
    context = fetch_notification_context()
    telegram_chatid = context.get('CONTACT_TELEGRAM_CHAT_ID')
    if not telegram_chatid: # e.g. empty field in user database
        sys.stdout.write("Cannot send Telegram message: Empty destination chat id")
        sys.exit(2)
    text = construct_message_text(context)
    send_telegram_message(telegram_bot_token, telegram_chatid, text)

main()
```

Thay TOKEN bằng TOKEN chúng ta lấy được qua chat box @BotFather

Bước 2: Cấp quyền cho file `telegram.py`
```
chmod +x /omd/sites/monitoring/share/check_mk/notifications/telegram.py
```
Restart lại omd server :
```
omd restart
```

Bước 3: Cấu hình trên WATO 

Tạo một Attributes User. Sau đó save và cập nhật thay đổi 

![](../images/canh-bao-tele/screen_5.png)

![](../images/canh-bao-tele/screen_6.png)

![](../images/canh-bao-tele/screen_7.png)

Bước 4: Tạo ra user. Sau đó lưu lại và cập nhật thay đổi 

![](../images/canh-bao-tele/screen_8.png)

![](../images/canh-bao-tele/screen_9.png)

Bước 5: Tạo thêm rule mới ở trong  `notifications`

![](../images/canh-bao-tele/screen_10.png)

![](../images/canh-bao-tele/screen_11.png)

![](../images/canh-bao-tele/screen_12.png)

Bước 6: Kiểm tra cảnh báo khi tắt máy 

![](../images/canh-bao-tele/screen_13.png)

